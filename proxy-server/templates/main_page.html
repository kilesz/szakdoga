<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>weatherpage</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
</head>
<body>
  <div class="sidenav">
    <div id="ip-listt" class="ip-listt">
      <h2>IP Addresses</h2>
      <div class="ips">
          <ul>
              <li onclick="choosenDescribe('10.25.33.11')">10.25.33.11<br>
              <canvas id="C_panel_1" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_1" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_1" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.216')">10.25.33.216<br>
              <canvas id="C_panel_2" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_2" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_2" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.211')">10.25.33.211<br>
              <canvas id="C_panel_3" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_3" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_3" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.201')">10.25.33.201<br>
              <canvas id="C_panel_4" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_4" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_4" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.231')">10.25.33.231<br>
              <canvas id="C_panel_5" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_5" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_5" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.221')">10.25.33.221<br>
              <canvas id="C_panel_6" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_6" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_6" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.206')">10.25.33.206<br>
              <canvas id="C_panel_7" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_7" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_7" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.241')">10.25.33.241<br>
              <canvas id="C_panel_8" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_8" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_8" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.236')">10.25.33.236<br>
              <canvas id="C_panel_9" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_9" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_9" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
              <li onclick="choosenDescribe('10.25.33.251')">10.25.33.251<br>
              <canvas id="C_panel_10" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_battery_10" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas>
              <canvas id="C_wifi_10" class="status-canvas" style="border:1px solid #FFFFFF;"></canvas></li>
          </ul>
      </div>
      <button onclick="fetchAndUpdate()">Update Datas</button>
    </div>
  </div>
  <div class="main-content">
    
    <div id="loader" class="loader"></div>
    <h1 id="welcome-message" class="welcome-message">Welcome on my Weatherpage!</h1>
    <div id="content" class="content-container">
      <h1>Data Query</h1>
    
      <form id="historicalDataForm" class="page-section">
          <label for="hostid">Host ID:</label>
          <select id="hostid" name="hostid" required>
          </select>
          
          <label for="property">Property:</label>
          <select id="property" name="property" required>
              <option value="Start">Start</option>
              <option value="SYS_Type">SYS_Type</option>
              <option value="SYS_TimeStamp">SYS_TimeStamp</option>
              <option value="SYS_Status">SYS_Status</option>
              <option value="DeviceID">DeviceID</option>
              <option value="EVState">EVState</option>
              <option value="ZeroFilter">ZeroFilter</option>
              <option value="ConcentrationFilter">ConcentrationFilter</option>
              <option value="Concentration">Concentration</option>
              <option value="GPS_TimeStamp">GPS_TimeStamp</option>
              <option value="Latitude">Latitude</option>
              <option value="Longitude">Longitude</option>
              <option value="ComWait">ComWait</option>
              <option value="ComCounter">ComCounter</option>
              <option value="Barometric_pr">Barometric_pr</option>
              <option value="Air_temperature">Air_temperature</option>
              <option value="Relative_humidity">Relative_humidity</option>
              <option value="Wind_direction">Wind_direction</option>
              <option value="Wind_speed">Wind_speed</option>
              <option value="Pressure_pump">Pressure_pump</option>
              <option value="Battery_Volt">Battery_Volt</option>
              <option value="Panel_Volt">Panel_Volt</option>
          </select>
          
          <label for="start_datetime">Start time:</label>
          <input type="datetime-local" id="start_datetime" name="start_datetime" required>
          
          <label for="end_datetime">End time:</label>
          <input type="datetime-local" id="end_datetime" name="end_datetime" required>
          
          <button type="submit" id="submit">Submit</button>
          
      </form>
      <form id="queryForm">
          <label for="queryname">Query name:</label>
          <input type="text" id="queryname" name="queryname">
          <button type="button" onclick="saveQuery()">Save</button>

          <label for="queryloader">Select the query you want to load:</label>
          <select id="queryloader" name="queryloader" onchange="loadQuery()">
            <option value="">-- Select a saved query --</option>
          </select>
          <button type="button" onclick="deleteQuery()">Delete Selected Query</button>
          <button type="button" onclick="setAsFavorite()">Favorite</button>
          <div id="favorite-display" style="margin-top: 10px;"></div>
      </form>

      <div class="inline-form">
        <input type="number" id="windowInput" placeholder="Ablakméret" min="1">
        <button onclick="enableMovingAverage()">Ablakos átlagolás</button>
      </div>
      <div class="inline-form">
        <select id="correlateQuery1"></select>
        <select id="correlateQuery2"></select>
        <button onclick="runCorrelation()">Korreláció számítása</button>
      </div>

      <div id="correlationResult" style="color: white; margin-top: 10px;"></div>

      <div id="list" ></div>
      <button onclick="csvDownload()" style="width: 200px;">Download Data</button>
      <div id="resultDiv"></div>
      <div class="page-section">
        <div class="chart-section">
        <div class="full-width-chart-container">
        <canvas id="batteryVolt" class="full-width-chart"></canvas>
        </div>
        </div>
      </div>
      <div id="map"></div>

      </div>

    </div>
    <div id="background-overlay"></div>
  </div>
      <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
      <script>
        console.log(window);
        Chart.register(ChartZoom);
      </script>
      <script>

        const gbv = document.getElementById('batteryVolt');
        const content = document.getElementById('content');
        const overlay = document.getElementById('background-overlay');
        const ip_listt = document.getElementById('ip-listt');
        const welcome_message = document.getElementById('welcome-message');
        const queried_graph = document.getElementById('queried_graph');
        const starting_time_selector = document.getElementById('StartingTimeSelector');
        const ending_time_selector = document.getElementById('EndingTimeSelector');
        const ipListItems = document.querySelectorAll('.ips li');
        const resultDiv = document.getElementById("resultDiv");
        const result = document.getElementById("result");
        const queryname = document.getElementById("queryname");

        const data = [];
        let globalData = [];
        let chartInstance1 = null;
        let csvSave = 0;
        let qSace = 0;
        let lastDisplayedData = null;

        var map = L.map('map').setView([47.4979, 19.0402], 13);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap közreműködők'
        }).addTo(map);

        // mapikon beállítása
        var nodeIcon = L.icon({
            iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34]
        });
        
        async function mapDrawPosition(){
          try {
            const response = await fetch('/positions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: 'positions'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP hiba: ${response.status}`);
            }

            const positions = await response.json();
            
            // Előző markerek törlése
            map.eachLayer(layer => {
                if (layer instanceof L.Marker) {
                    map.removeLayer(layer);
                }
            });

          // Új markerek hozzáadása
          for (const [id, node] of Object.entries(positions)) {
              const marker = L.marker([node.Latitude, node.Longitude], {
                  icon: nodeIcon
              }).addTo(map);
              
              marker.bindPopup(`
                  <b>Node ${id}</b><br>
                  IP: ${node.IP}<br>
                  Koordináták: ${node.Latitude.toFixed(6)}, ${node.Longitude.toFixed(6)}
              `);
          }

          // Automatikus zoomolás az összes marker-re, ha vannak adatok
          if (Object.keys(positions).length > 0) {
              const markers = Object.values(positions).map(node => [node.Latitude, node.Longitude]);
              const bounds = L.latLngBounds(markers);
              map.fitBounds(bounds, { padding: [50, 50] });
          }

          } catch (err) {
              console.error("Hiba a pozíciók lekérésekor:", err);
              alert("Hiba történt a pozíciók betöltésekor. Próbáld újra később.");
          }
        }
        
        //kerekítés
        function rounding(value, decimals = 2) {
          if (value === null || isNaN(value)) return null;
          const factor = Math.pow(10, decimals);
          return Math.round(value * factor) / factor;
        }

        // A freshdata ip cím alapján való adat keresése #pipa pipa
        function cutter(neededData, freshdata,ip){
          const nodeEntry = freshdata.find(entry => entry[1] === ip);  
            if (nodeEntry && nodeEntry[2] && nodeEntry[2].length > 0) {
              const sensorData = nodeEntry[2];
              return sensorData.find(item => item[0] === neededData);
            }
          return null;
        }

        //A legfrissebb adatok kiírása #pipa pipa
        async function choosenDescribe(ip){
          const list = document.getElementById('list');
          list.innerHTML = '';
          const freshdata = await fetchAndUpdate();
          
          try {
            
            const nodeEntry = freshdata.find(entry => entry[1] === ip);
            
            if (!nodeEntry || !nodeEntry[2]) {
                throw new Error('No data available for selected IP');
            }
            
            const keys = [
              "Start", "SYS_Type", "SYS_TimeStamp", "SYS_Status", "Device_ID", "EV_State",
              "ZeroFilter", "ConcentrationFilter", "Concentration", "GPS_TimeStamp",
              "Latitude", "Longitude", "ComWait", "ComCounter", "Barometric_P",
              "Air_temperature", "Relative_humidity", "Wind_direction", "Wind_speed",
              "Pressure_pump", "Battery_Volt", "Panel_Volt"
            ];

            let text = `IP: ${nodeEntry[1]}, Date: ${nodeEntry[0]}\n`;

            for (const key of keys) {
              const entry = cutter(key, freshdata, ip);
              if (entry) {
                let value = entry[1];

                if (key === "Battery_Volt" || key === "Panel_Volt") {
                  value = rounding(value / 10);
                }

                text += `${key}: ${value}\n`;
              } else {
                text += `${key}: N/A\n`;
              }
            }
            
            lastDisplayedData = text;

            const li = document.createElement('li');
            li.style.color = 'yellow';
            li.textContent = text;
            list.appendChild(li);
          } catch (error) {
              console.error('Error in choosenDescribe:', error);
              const li = document.createElement('li');
              li.style.color = 'red';
              li.textContent = 'Error loading data';
              list.appendChild(li);
          }
        }

        // A legfrissebb adatok lekérdezése #pipa pipa
        async function fetchAndUpdate() {
          try   {
            const response = await fetch('/data');

            if (!response.ok) {
                throw new Error(`Hálózati hiba: ${response.status}`);
            }

            const text = await response.text();

            if (!text) {
                throw new Error("Üres válasz a szervertől!");
            }

            const jsonData = JSON.parse(text);
            console.log("JSON adatok:", jsonData);

            if (Array.isArray(jsonData)) {
              return jsonData;
            }
            if (jsonData.data && typeof jsonData.data === 'string') {
              try {
                  const freshdata = JSON.parse(jsonData.data);
                  return freshdata;
              } catch (e) {
                  console.error('Hiba a data field parse-olásakor:', e);
                  return jsonData;
              }
            } else {
              return jsonData;
            }
            return(freshdata);
          } catch (error) {
            console.error('Hiba a fetchelés közben:', error);
            document.getElementById('error-display').textContent = `Hiba az adatok frissítésekor: ${error.message}`;
          }
        }

        //csv fájl letöltése #pipa pipa
        function csvDownload() {
          if (!lastDisplayedData) {
            alert("Please select an IP first to view data before downloading.");
            return;
          }
        
          const lines = lastDisplayedData.trim().split('\n');
          const headers = ['Key', 'Value'];
        
          const rows = lines.slice(2).map(line => {
            const index = line.indexOf(':');
            return [line.slice(0, index).trim(), line.slice(index + 1).trim()];
          });
        
          const ipLine = lines[0];
          const dateLine = lines[1];
          const [ipKey, ipValue] = ipLine.split(/:\s(.+)/);
          const [dateKey, dateValue] = dateLine.split(/:\s(.+)/);
          rows.unshift([dateKey, dateValue]);
          rows.unshift([ipKey, ipValue]);
        
          let csvContent = headers.join(',') + '\n';
          csvContent += rows.map(row => row.join(':')).join('\n');
        
          const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.setAttribute('href', url);
          link.setAttribute('download', 'data.csv');
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        // IP-címek színének frissítése #pipa pipa
        function updateIpColors(freshdata) {
          ipListItems.forEach((li, index) => {
              const ip = li.textContent.trim();
              const panelCanvasId = `C_panel_${index + 1}`;
              const batteryCanvasId = `C_battery_${index + 1}`;
              const wifiCanvasId = `C_wifi_${index + 1}`;

              const panelCanvas = document.getElementById(panelCanvasId);
              const batteryCanvas = document.getElementById(batteryCanvasId);
              const wifiCanvas = document.getElementById(wifiCanvasId);
              
              const panelVoltEntry = cutter("Panel_Volt", freshdata, ip);
              const batteryVoltEntry = cutter("Battery_Volt", freshdata, ip);
              //const wifiSignalEntry = sensorData.find(item => item[0] === "Wifi_signal");

              const panelVolt = panelVoltEntry ? rounding(panelVoltEntry[1] / 10) : null;
              const batteryVolt = batteryVoltEntry ? rounding(batteryVoltEntry[1] / 10) : null;
              //const wifiSignal = wifiSignalEntry ? wifiSignalEntry[1] : null;

              const nodeEntry = freshdata.find(entry => entry[1] === ip); 

              if (nodeEntry && nodeEntry[2] && nodeEntry[2].length > 0) {
                  li.style.color = '#90ee90';

                  if (panelVolt !== null) {
                      drawVoltageIndicator(panelCanvas, panelVolt, 0, 25, 'Panel: ');
                  } else {
                      clearCanvas(panelCanvas);
                  }
                  
                  if (batteryVolt !== null) {
                      drawVoltageIndicator(batteryCanvas, batteryVolt, 11.6, 14, 'Batt: ');
                  } else {
                      clearCanvas(batteryCanvas);
                  }

                  /*if (wifiSignal !== null) {
                      drawWifiIndicator(wifiCanvas, wifiSignal);
                  } else {
                      clearCanvas(wifiCanvas);
                  }*/
                  
              } else {
                  li.style.color = 'white';
                  clearCanvas(panelCanvas);
                  clearCanvas(batteryCanvas);
                  //clearCanvas(wifiCanvas);
              }
          });
        }
      
        // értékek kirajzolása rubrikákba #pipa pipa
        // panel: 0-25V, battery: 11.6-14V
        function drawVoltageIndicator(canvas, voltage, minVoltage, maxVoltage, prefix = '') {
          if (!canvas) return;
          
          const ctx = canvas.getContext("2d");
          const percentage = Math.min(100, Math.max(0, ((voltage - minVoltage) / (maxVoltage - minVoltage)) * 100));
          
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          ctx.strokeStyle = 'white';
          ctx.strokeRect(0, 0, canvas.width, canvas.height);
          
          ctx.fillStyle = prefix.includes('Panel') ? '#4CAF50' : '#2196F3';
          
          const fillHeight = (canvas.height * percentage) / 100;
          const yStart = canvas.height - fillHeight;
          
          ctx.fillRect(0, yStart, canvas.width, fillHeight);
          
          if (canvas.width > 25) {
              ctx.fillStyle = 'white';
              ctx.font = '8px Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(`${prefix}${voltage.toFixed(1)}V`, canvas.width/2, canvas.height/2);
          }
        }
        //canvas tisztitása #pipa pipa
        function clearCanvas(canvas) {
            if (!canvas) return;
            
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'white';
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
        }
        //kirajzolja a lekért grafikont #pipa pipa
        function graphDraw(data,windowSize = null){
          console.log("data:", data);

          if (!data || data.length === 0) {
            console.error("Nincsenek adatok a grafikonhoz!");
            return;
          }

          if (chartInstance1 !== null) {
            chartInstance1.destroy();
          }
          Chart.register(ChartZoom);

          const datasets = [
            {
              label: 'Graf',
              data: data.map(item => item.y),
              borderColor: 'blue',
              borderWidth: 2,
              tension: 0.1
            }
          ];

          // Ablakos átlagolás
          if (windowSize && windowSize > 1 && windowSize <= data.length) {
            const averagedData = movingAverage(data, windowSize);
            datasets.push({
              label: `Mozgóátlag (${windowSize})`,
              data: averagedData.map(item => ({ x: item.x, y: item.y })),
              borderColor: 'red',
              borderWidth: 2,
              borderDash: [5, 5],
              tension: 0.1
            });
          }

          chartInstance1=new Chart(gbv, {
                type: 'line',
                data: {
                  labels: data.map(item => item.x),
                  datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                      padding: {
                        top: 20,
                        right: 20,
                        bottom: 20,
                        left: 20
                      }
                    },
                    plugins: {
                      legend: {
                        position: 'top',
                        labels: {
                          color: 'white'
                        }
                      },
                      zoom: {
                        pan: {
                          enabled: true,
                          mode: 'xy',
                          drag: true 
                        },
                        zoom: {
                          wheel: {
                            enabled: true,
                            modifierKey: 'ctrl'
                          },
                          pinch: {
                            enabled: true
                          },
                          mode: 'xy',
                        }                  
                      }
                    },
                    scales: {
                      x: {
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                      },
                      y: {
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                      }
                    }
                  }
              });
              
              window.addEventListener('resize', function() {
                chartInstance1.resize();
              });
        }
        
        //töltő képernyő #pipa pipa
        function showLoader() {
            loader.style.display = 'block';
            overlay.style.display = 'block';
        }

        function hideLoader() {
            loader.style.display = 'none';
            overlay.style.display = 'none';
            content.style.display = 'flex';
            ip_listt.style.display = 'block';
            welcome_message.style.display = 'block';
        }
        
        //percenkénti periodikus frissítés #pipa pipa
        function startPeriodicUpdate() {
            setInterval(async () => {
                showLoader();
                const freshdata = await fetchAndUpdate();
                updateIpColors(freshdata);
                hideLoader();
            }, 60000);
        }



        //Elmenteni a lekérdezést #pipa pipa
        function saveQuery(){
          const queryName = document.getElementById('queryname').value.trim();

          if (!queryName) {
            alert("Please enter a query name!");
            return;
          }

          const formData = {
            hostid: document.getElementById('hostid').value,
            property: document.getElementById('property').value,
            start_datetime: document.getElementById('start_datetime').value,
            end_datetime: document.getElementById('end_datetime').value
          };

          const savedQueries = JSON.parse(localStorage.getItem('savedQueries')) || {};
          savedQueries[queryName] = formData;
          localStorage.setItem('savedQueries', JSON.stringify(savedQueries));

          updateQueryDropdown();
          alert(`Query "${queryName}" saved successfully!`);
        }
        
        //Elmentet lekérdezések listázása #pipa pipa
        function updateQueryDropdown() {
          const savedQueries = JSON.parse(localStorage.getItem('savedQueries')) || {};
          const dropdown = document.getElementById('queryloader');
        
          dropdown.innerHTML = '<option value="">-- Select a saved query --</option>';
        
          Object.keys(savedQueries).forEach(queryName => {
            const option = document.createElement('option');
            option.value = queryName;
            option.textContent = queryName;
            dropdown.appendChild(option);
          });          
        }

        //Lekérdezés betöltése #pipa pipa
        function loadQuery() {
          const dropdown = document.getElementById('queryloader');
          const selectedQueryName = dropdown.value;
        
          if (!selectedQueryName) return;
        
          const savedQueries = JSON.parse(localStorage.getItem('savedQueries')) || {};
          const queryData = savedQueries[selectedQueryName];
        
          if (queryData) {
            document.getElementById('hostid').value = queryData.hostid || '';
            document.getElementById('property').value = queryData.property || '';
            document.getElementById('start_datetime').value = queryData.start_datetime || '';
            document.getElementById('end_datetime').value = queryData.end_datetime || '';
          }
        }

        //Alapértelmezett(kedvenc) kiírása #pipa pipa
        const favoriteName = localStorage.getItem('favoriteQuery');
        if (favoriteName) {
          document.getElementById('favorite-display').textContent = `Alapértelmezett: ${favoriteName}`;
        }

        //Alapértelmezett(kedvenc) lekérdezés beállítása #pipa pipa
        function setAsFavorite() {
          const selectedQuery = document.getElementById('queryloader').value;
          if (!selectedQuery) {
            alert("Előbb válassz ki egy lekérdezést a listából!");
            return;
          }
          
          localStorage.setItem('favoriteQuery', selectedQuery);
          alert(`"${selectedQuery}" most már az alapértelmezett lekérdezésed!`);
        }

        //Lekérdezés törlése #pipa pipa
        function deleteQuery() {  
          const selectedQuery = document.getElementById('queryloader').value;
          const savedQueries = JSON.parse(localStorage.getItem('savedQueries'));
          delete savedQueries[selectedQuery];
          localStorage.setItem('savedQueries', JSON.stringify(savedQueries));
          updateQueryDropdown();
        }



        //Pearson-féle korrelációs együttható számítása #pipa pipa
        function calculateCorrelation(data1, data2) {
          if (!data1 || !data2 || data1.length !== data2.length || data1.length < 2) {
            return null;
          }
          const arr1 = Array.isArray(data1) ? data1.map(item => item.x || item) : [];
          const arr2 = Array.isArray(data2) ? data2.map(item => item.x || item) : [];
        
          const n = arr1.length;
          const mean1 = arr1.reduce((a, b) => a + b, 0) / n;
          const mean2 = arr2.reduce((a, b) => a + b, 0) / n;
        
          let covariance = 0;
          let variance1 = 0;
          let variance2 = 0;
        
          for (let i = 0; i < n; i++) {
            const diff1 = arr1[i] - mean1;
            const diff2 = arr2[i] - mean2;
            covariance += diff1 * diff2;
            variance1 += diff1 * diff1;
            variance2 += diff2 * diff2;
          }
        
          const denominator = Math.sqrt(variance1 * variance2);
          
          return denominator === 0 ? null : covariance / denominator;
        }

        //korreéláció müveletek meghívása #pipa pipa
        async function runCorrelation() {
          try {
            const query1 = document.getElementById('correlateQuery1').value;
            const query2 = document.getElementById('correlateQuery2').value;
            
            if (!query1 || !query2) {
              alert("Válassz ki két lekérdezést a korrelációhoz!");
              return;
            }
        
            showLoader();
            
            const response1 = await fetchQueryData(query1);
            const response2 = await fetchQueryData(query2);
            
            const alignedData = alignDataByTime(response1, response2);
            
            if (!alignedData || alignedData.data1.length < 2) {
              throw new Error("Nincs elég közös adatpont a korrelációhoz!");
            }
        
            const correlation = calculateCorrelation(alignedData.data1, alignedData.data2);
            const roundedCorr = rounding(correlation, 3);
            
            displayCorrelationResult(query1, query2, roundedCorr, alignedData.data1.length);
            
            drawCorrelationChart(alignedData.data1, alignedData.data2, query1, query2);
            
          } catch (error) {
            console.error("Hiba a korreláció számítása közben:", error);
            document.getElementById('correlationResult').innerHTML = 
              `<span style="color: red;">Hiba: ${error.message}</span>`;
          } finally {
            hideLoader();
          }
        }

        //korreláció mentett adatok lekérdezése #pipa pipa
        async function fetchQueryData(queryName) {
          const savedQueries = JSON.parse(localStorage.getItem('savedQueries')) || {};
          const query = savedQueries[queryName];
          
          if (!query) {
            throw new Error(`Nem található a(z) ${queryName} lekérdezés!`);
          }
        
          const response = await fetch('/historical-data', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
              hostid: query.hostid,
              property: query.property,
              start_datetime: query.start_datetime,
              end_datetime: query.end_datetime
            })
          });
        
          if (!response.ok) {
            throw new Error(`Hálózati hiba: ${response.status}`);
          }
        
          return await response.json();
        }

        //korreláció idő alapú szelektálás
        function alignDataByTime(data1, data2) {
          const map1 = createTimeMap(data1);
          const map2 = createTimeMap(data2);
          
          const commonTimes = new Set([...Object.keys(map1), ...Object.keys(map2)]);
          
          const aligned1 = [];
          const aligned2 = [];
          
          commonTimes.forEach(time => {
            if (map1[time] && map2[time]) {
              aligned1.push(map1[time]);
              aligned2.push(map2[time]);
            }
          });
          
          return {
            data1: aligned1,
            data2: aligned2,
            commonCount: aligned1.length
          };
        }
        //korreláció kulcsok létrehozása idő alapján
        function createTimeMap(data) {
          const map = {};
          data.forEach(item => {
            const timeKey = new Date(item.x).toISOString().slice(0, 16);
            map[timeKey] = item.y;
          });
          return map;
        }

        //korreláció eredmény kiírása #pipa pipa
        function displayCorrelationResult(query1, query2, correlation, dataPoints) {
          const resultDiv = document.getElementById('correlationResult');
          
          let interpretation = "";
          if (correlation !== null) {
            const absCorr = Math.abs(correlation);
            if (absCorr > 0.8) {
              interpretation = "Erős korreláció";
            } else if (absCorr > 0.5) {
              interpretation = "Közepes korreláció";
            } else if (absCorr > 0.3) {
              interpretation = "Gyenge korreláció";
            } else {
              interpretation = "Nagyon gyenge vagy nincs korreláció";
            }
            
            const direction = correlation > 0 ? "pozitív" : "negatív";
            interpretation += `, ${direction} irányú`;
          }
          
          resultDiv.innerHTML = `
            <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
              <h3>Korreláció eredménye</h3>
              <p><strong>${query1}</strong> és <strong>${query2}</strong> között:</p>
              <p style="font-size: 24px; font-weight: bold; color: ${getCorrelationColor(correlation)}">
                ${correlation !== null ? correlation : "Nem számolható"}
              </p>
              ${correlation !== null ? `
                <p>${interpretation}</p>
                <p>Alapjául szolgáló adatpontok száma: ${dataPoints}</p>
              ` : ''}
            </div>
          `;
        }

        //korreláció színe #pipa pipa
        function getCorrelationColor(correlation) {
          if (correlation === null) return "gray";
          const absCorr = Math.abs(correlation);
          if (absCorr > 0.7) return "#4CAF50"; 
          if (absCorr > 0.4) return "#FFC107"; 
          if (absCorr > 0.1) return "#FF9800"; 
          return "#F44336";
        }

        //korrelációs diagram kirajzolása #pipa pipa
        function drawCorrelationChart(data1, data2, label1, label2) {
          const ctx = document.createElement('canvas');
          ctx.style.maxHeight = "400px";
          ctx.style.width = "100%";
          
          const container = document.getElementById('correlationResult');
          container.appendChild(ctx);
          
          new Chart(ctx, {
            type: 'scatter',
            data: {
              datasets: [
                {
                  label: `${label1} vs ${label2}`,
                  data: data1.map((val, i) => ({x: val, y: data2[i]})),
                  borderColor: '#3e95cd',
                  backgroundColor: '#3e95cd80',
                  pointRadius: 5
                }
              ]
            },
            options: {
              responsive: true,
              plugins: {
                title: {
                  display: true,
                  text: 'Korrelációs diagram',
                  color: 'white'
                },
                legend: {
                  labels: {
                    color: 'white'
                  }
                }
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: label1,
                    color: 'white'
                  },
                  ticks: { color: 'white' },
                  grid: { color: 'rgba(255,255,255,0.1)' }
                },
                y: {
                  title: {
                    display: true,
                    text: label2,
                    color: 'white'
                  },
                  ticks: { color: 'white' },
                  grid: { color: 'rgba(255,255,255,0.1)' }
                }
              }
            }
          });
        }

        //korreláció input beállítások #pipa pipa
        function updateCorrelationDropdowns() {
          const savedQueries = JSON.parse(localStorage.getItem('savedQueries')) || {};
          const dropdown1 = document.getElementById('correlateQuery1');
          const dropdown2 = document.getElementById('correlateQuery2');
          
          dropdown1.innerHTML = '';
          dropdown2.innerHTML = '';
          
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = '-- Válassz lekérdezést --';
          dropdown1.appendChild(defaultOption.cloneNode(true));
          dropdown2.appendChild(defaultOption.cloneNode(true));
          
          Object.keys(savedQueries).forEach(queryName => {
            const option = document.createElement('option');
            option.value = queryName;
            option.textContent = queryName;
            dropdown1.appendChild(option.cloneNode(true));
            dropdown2.appendChild(option.cloneNode(true));
          });
        }



        //Ablakos átlag számítás #pipa pipa
        function movingAverage(data, windowSize) {
          const result = [];
          for (let i = 0; i <= data.length - windowSize; i++) {
            let sum = 0;
            for (let j = 0; j < windowSize; j++) {
              sum += data[i + j].y;
            }
            result.push({
              x: data[i + Math.floor(windowSize / 2)].x,
              y: sum / windowSize
            });
          }
          return result;
        }
        
        //Ablakos átlag hibakezelés #pipa pipa
        function enableMovingAverage() {
          const input = document.getElementById("windowInput");
          const windowSize = parseInt(input.value);
        
          if (!globalData || globalData.length === 0) {
            alert("Először kérj le adatot!");
            return;
          }
        
          if (isNaN(windowSize) || windowSize <= 1 || windowSize > globalData.length) {
            alert("Adj meg egy 2 és " + globalData.length + " közötti ablakméretet!");
            return;
          }
        
          graphDraw(globalData, windowSize);
        }



        async function loadHosts() {
          try {
              const response = await fetch('/hosts', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: 'hosts'
              });
              
              if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
              }
              
              const hosts = await response.json();
              const hostSelect = document.getElementById('hostid');
              
              while (hostSelect.firstChild) {
                  hostSelect.removeChild(hostSelect.firstChild);
              }
              
              hosts.forEach(host => {
                  const option = document.createElement('option');
                  option.value = host;
                  option.textContent = host;
                  hostSelect.appendChild(option);
              });
              
              if (hosts.length > 0) {
                  hostSelect.value = hosts[0];
              }
              
          } catch (error) {
              console.error('Hiba a hosztok betöltésekor:', error);
              const errorDiv = document.createElement('div');
              errorDiv.style.color = 'red';
              errorDiv.textContent = 'Hiba a hosztok betöltésekor. Próbálja újra később.';
              document.getElementById('historicalDataForm').prepend(errorDiv);
          }
        }

 

        //Oldal betöltésekor zajló műveletek #pipa pipa
        document.addEventListener('DOMContentLoaded',async function() {
          
          showLoader();
          const freshdata = await fetchAndUpdate();
          updateIpColors(freshdata);
          mapDrawPosition();
          hideLoader();
          startPeriodicUpdate();  

          loadHosts();
          updateQueryDropdown();
          updateCorrelationDropdowns();
          
          const favoriteQuery = localStorage.getItem('favoriteQuery');
          if (favoriteQuery) {
            document.getElementById('queryloader').value = favoriteQuery;
            loadQuery();
            setTimeout(() => {
              if (form) {
                form.requestSubmit();
              }
            }, 1000);
          }
          
        });

        //Görgővel zoomolás ctrl+görgővel #pipa pipa
        gbv.addEventListener('wheel', function(evt) {
          if (!evt.ctrlKey) {
            evt.preventDefault();
          }
        }, { passive: false });

        const form = document.getElementById("historicalDataForm");

        // A submit gombra általi grafikon lekérdezés #pipa pipa
        form.addEventListener('submit', async function(e) {
          e.preventDefault();
          showLoader();
          try {
              resultDiv.innerHTML = "";
              
              const response = await fetch('/historical-data', {  
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                      hostid: document.getElementById('hostid').value,
                      property: document.getElementById('property').value,
                      start_datetime: document.getElementById('start_datetime').value + ':00Z',
                      end_datetime: document.getElementById('end_datetime').value + ':00Z'
                  })
              });
              
              if (!response.ok) {
                  const error = await response.text();
                  throw new Error(error || `HTTP error! status: ${response.status}`);
              }
              
              const data = await response.json();
              console.log("Lekért adat:", data);
              globalData = data;
              graphDraw(data);
              

          } catch (error) {
              console.error('Hiba történt:', error);
              resultDiv.innerHTML = `<p style="color: red;">Hiba történt: ${error.message}</p>`;
          } finally {
            hideLoader();
          }
        });

      </script>
      
</body>
</html>